#pragma config(Sensor, S1,     lightsensor,    sensorLightActive)
#pragma config(Sensor, S2,     sonarsensor,    sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int x, y, x_max = 7, y_max = 9; //set the boundaries for the maze.
char direction = 'N'; //eg. 'N'(NORTH)

char find_direction(int angle, char side); //PASSES: direction, angle, side - RETURNS: new direction.
void calculate_position(void);
int scan_mine(void); //function checks for a mine in the square ahead. RETURNS: 1 if mine detected. 0 if not.
int scan_block(void); //function checks for a block in the square ahead. RETURNS: 1 if block detected. 0 if not.
void go_forward(void); //function enters the square ahead.
void turn_left(void); //function turns the robot 90 degrees to the left in its current square.
void turn_right(void); //function turns the robot 90 degrees to the right in its current square.
void grab_block(void); //function grabs the block in the square ahead and stays in the square ahead.
int search_block(void);

task main()
{
    int found_block, found_mine, have_block, search_;
    int angle; //eg. 90/180 (degrees)
    found_block = 0;
    have_block = 0;
    x = 4; //starting position on x-axis
    y = 1; //starting position on y-axis

    while (found_block == 0) //while searching for block (block not found):
    {
        search_ = search_block();// *SEARCH FOR BLOCK*

        if (search_ == 1) //if block found:
        {
            found_block = 1;
        }//end if()
        else if (search_ == 2) //if mine found:
        {
            if (direction == 'N')
            {
                turn_right();
                direction = find_direction(90, 'R');
                go_forward();
                calculate_position();
                turn_left();
                direction = find_direction(90, 'L');
                go_forward();
                calculate_position();
            }//end if()
            else if (direction == 'W')
            {
                turn_right();
                direction = find_direction(90, 'R');
                go_forward();
                calculate_position();
                turn_left();
                direction = find_direction(90, 'L');
            }//end else if()
            else if (direction == 'E')
            {
                turn_left();
                direction = find_direction(90, 'L');
                go_forward();
                calculate_position();
                turn_right();
                direction = find_direction(90, 'R');
            }//end else if()
            else if (direction == 'S')
            {
                turn_right();
                turn_right();
                direction = find_direction(180, 'R');
            }//end else if()

        }//end else if()

    }//end while()

    if (found_block == 1)
    {
        grab_block();
    }//end if()

    while (found_block == 1) //once block if found:
    {
        //SEARCH FOR SAFE ZONE:
        if (direction == 'N')
        {
            if (y <= y_max) //if not at the safe zone:
            {
                go_forward();
                calculate_position();
            }//end if()
            else if (y > y_max) //if in the safe zone:
            {
                motor[motorA] = -30;
                wait1Msec(1000);
            }//end else if()

        }//end if()
        else if (direction == 'W')
        {
            turn_right();
            direction = find_direction(90, 'R');
        }//end if()
        else if (direction == 'E')
        {
            turn_left();
            direction = find_direction(90, 'L');
        }//end else if()
        else if (direction == 'S')
        {
            turn_left();
            turn_left();
            direction = find_direction(180, 'L');
        }//end else if()

    }//end while()

}//end main()

char find_direction(int angle, char side)
{
	if (direction == 'N')
	{
		if (side == 'L' && angle == 90)
		{
			direction = 'W';
			return(direction);
		}//end if()
			else if (side == 'L' || side == 'R' && angle == 180)
			{
				direction = 'S';
				return(direction);
			}//end else if()
			else if (side == 'R' && angle == 90)
			{
				direction = 'E';
				return(direction);
			}//end else if()
 	}//end if() NORTH.

 	if (direction == 'W')
 	{
 		if (side == 'L' && angle == 90)
 		{
 			direction = 'S';
 			return(direction);
 		}//end if()
 		else if (side == 'L' || side == 'R' && angle == 180)
 		{
 			direction = 'E';
 			return(direction);
 		}//end else if()
 		else if (side == 'R' && angle == 90)
 		{
 			direction = 'N';
 			return(direction);
 		}//end else if()
 	}//end if() WEST.
 	if (direction == 'E')
 	{
 		if (side == 'L' && angle == 90)
 		{
 			direction = 'N';
 			return(direction);
 		}//end if()
 		else if (side == 'L' || side == 'R' && angle == 180)
 		{
 			direction = 'W';
 			return(direction);
 		}//end else if()
 		else if (side == 'R' && angle == 90)
 		{
 			direction = 'S';
 			return(direction);
 		}//end else if()
 	}//end if() EAST.
 	if (direction == 'S')
 	{
 		if (side == 'L' && angle == 90)
 		{
 			direction = 'E';
 			return(direction);
 		}//end if()
 		else if (side == 'L' || side == 'R' && angle == 180)
 		{
 			direction = 'N';
 			return(direction);
 		}//end if()
 		else if (side == 'R' && angle == 90)
 		{
 			direction = 'W';
 			return(direction);
 		}//end else if()
 	}//END IF() SOUTH

 	return('N');
}//end find_direction()

void calculate_position(void)
{
    if (direction == 'N')
    {
        y++;
    }//end if()
    else if(direction == 'S')
    {
        y--;
    }//end else if()
    else if (direction == 'W')
    {
        x--;
    }//end else if()
    else if (direction == 'E')
    {
        x++;
    }//end else if()

    nxtDisplayStringAt(0, 31, "x: %d y: %d", x, y);

}//end calculate_position()

int scan_mine(void)
{
    if (SensorValue(lightsensor) < 50)//if mine detected in the square ahead:
    {
        return(1);
    }//end if()
    else if (SensorValue(lightsensor) > 50)//if no mine detected in the square ahead:
    {
        return(0);
    }//end if()

    return(0);
}//end scan_mine()

int scan_block(void)
{
    if (SensorValue(sonarsensor) <= 10)//if block detected in the square ahead:
    {
        return(1);
    }//end if()
    else if (SensorValue(sonarsensor) > 10)//if no block detected in the square ahead:
    {
        return(0);
    }//end if()

    return(0);

}//end scan_block()

void go_forward(void)
{
  	nSyncedMotors = synchBC;
    nSyncedTurnRatio = 100;
  	nMotorEncoder[motorB] = 0;

    while (nMotorEncoder[motorB] < 285)
    {
        motor[motorB] = 20;
    }//end while()

}//end go_forward()

void turn_left(void)
{
		nSyncedMotors = synchBC; //sych motors
		nSyncedTurnRatio = -100;
		motor[motorB] = 25;
		wait1Msec(830);
}//end turn_left()

void turn_right(void)
{
		nSyncedMotors = synchCB; //sych motors
		nSyncedTurnRatio = -100;
		motor[motorC] = 25;
		wait1Msec(850);
}//end turn_left()

void grab_block(void)
{
    motor[motorA] = 30;
    wait1Msec(1000);
}//end grab_block()

int search_block(void)
{
    int found_block, found_mine;

    //Preform Checks:
    found_block = scan_block();
    found_mine = scan_mine();

    //DECIDE WHAT TO DO/WHAT DIRECTION TO MOVE:
    if (direction == 'N') //if facing NORTH:
    {
        turn_left();
        direction = find_direction(90, 'L');
        return(0); //operation executed successfully.
    }//end if()
    else if (direction == 'W') //if facing WEST:
    {
        if (found_block == 0) //if the coast is clear:
        {
            if (x > 0) //if not on the edge:
            {
                if (found_mine == 0) // if no mine ahead:
                {
                    go_forward();
                    calculate_position();
                    return(0); //operation executed successfully.
                }//end if()
                else if (found_mine == 1) //if theres a mine ahead:
                {
                    return(2);
                }//end if()

            }//end if()
            else if (x <= 0) //if on the edge:
            {
                turn_right(); //move onto the next row up:
                direction = find_direction(90, 'R');
                go_forward();
                calculate_position();
                turn_right();
                direction = find_direction(90, 'R');
                return(0); //operation executed successfully.
            }//end else if()

        }//end if()
        else if (found_block == 1) //if theres a block in the square ahead:
        {
            return(1);
        }//end if()

        if (found_mine) //if theres a mine in the square ahead:
        {
            return(2);
        }//end else if()

    }//end if()
    else if (direction == 'E') //if facing EAST:
    {
        if (found_block == 0) //if the coast is clear:
        {
            if (x < x_max) //if not at the edge:
            {
                if (found_mine == 0) //if no mine:
                {
                    go_forward();
                    calculate_position();
                    return(0); //operation executed successfully.
                }//end if()
                else if (found_mine == 1) //if theres a mine ahead:
                {
                    return(2);
                }//end else if()

            }//end if()
            else if (x >= x_max) //if at the edge:
            {
                turn_left(); //move onto the next row up:
                direction = find_direction(90, 'L');
                go_forward();
                calculate_position();
                turn_left();
                direction = find_direction(90, 'L');
                return(0); //operation executed successfully.

            }//end else if()

        }//end if()
        else if (found_block == 1) //if theres a block in the square ahead:
        {
            return(1);
        }//end if()

        if (found_mine == 1) //if theres a mine in the square ahead:
        {
            return(2);
        }//end else if()

    }//end else if()
    else if (direction == 'S') //if facing SOUTH:
    {
        if (found_block == 0 && found_mine == 0) //if the coast is clear:
        {
            turn_right();
            direction = find_direction(90, 'R');
            turn_right();
            direction = find_direction(90, 'R');
            return(0); //operation executed successfully.

        }//end if()
    }//end else if()

    return(0);
}//end search()
